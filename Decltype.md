# decltype
## Что это такое?
decltype — ключевое слово языка программирования C++, которое появилось в обновлённом стандарте C++11. 
Наряду с ключевым словом auto оно используется для выведения типов выражений, получаемых в качестве своего аргумента.  

Различие между decltype и auto в том, что auto теряет квалификаторы типов const и &, а decltype сохраняет их для дальнейшей работы.  

Также в стандарте С++11 ключевое слово decltype можно использовать для объявления типа возвращаемого функцией значения в тех случаях, 
когда применяется новый способ записи сигнатуры функции (в котором возвращаемое значение следует за списком её параметров).  

В обновлённом стандарте языка C++14 появилась возможность объявлять переменные со спецификатором типа decltype(auto), который предписывает компилятору выбирать для них тип данных на основе типа инициализатора.  

## Как использовать decltype?
decltype возвращает тип указанного выражения. 
decltype полезен, в основном, для разработчиков, создающих библиотеки шаблонов.  

Для определения типа параметра выражения компилятор использует следующие правила:  
 * Если параметр является идентификатором или выражением доступа к члену класса, то decltype(expression) в точности является типом сущности с именем expression.  
 * Если параметр является результатом вызова функции или оператора, то аргумент decltype(expression) является типом возвращаемого значения функции. Скобки вокруг перегруженного оператора игнорируются.  
 * Если параметр Expression является rvalue, то decltype(expression) является типом выражения. Если параметр Expression является lvalue, то decltype(expression) является ссылкой.  

Различие между decltype и auto в том, что auto теряет квалификаторы типов const и &, а decltype сохраняет их.  

decltype не вычисляет переданное ему выражение, а только оценивает его тип во время компиляции.  

Пример:  
```C++
int var;
const int&& fx();
struct A { double x; }
const A* a = new A();

decltype(fx()); 	// const int&&: cсылка rvalue на const int.
decltype(var); 	// int: тип переменной var.
decltype(a->x);  // double: тип поля x.
decltype((a->x));  // const double&: внутренние скобки делают аргумент выражением, а не доступом к члену класса. И, поскольку a объявляется как const указатель, тип является ссылкой на const double.
```

Ещё пример:  
```C++
int i;
decltype(i); // int
decltype(i + 1); // int
decltype((i)); // int&
decltype(i = 4); //int&
const int foo();
decltype(foo()) ;// int
int&& foo1();
decltype(foo1()) ;// int&&
```

### При инициализации
Помня о правилах вывода типов, описанных выше, `decltype` очень просто использовать при инициализации переменных:
```C++
int fun1() { return 10; }
char fun2() { return 'g'; }
  
int main()
{
    // Data type of x is same as return type of fun1()
    // and type of y is same as return type of fun2()
    decltype(fun1()) x;
    decltype(fun2()) y;
  
    return 0;
}
```

```C++
int main()
{
    int x = 5;
  
    // j will be of type int : data type of x
    decltype(x) j = x + 5;
  
    return 0;
}
```

### Возвращаемое значение функции
В C++11 можно использовать `decltype` вместе с `auto`, чтобы объявить функцию, тип возвращаемого значения которой зависит от типов её аргументов.  
Рассмотрим следующий пример кода, в котором тип возвращаемого значения шаблонной функции зависит от типов аргументов шаблона:  
```C++
template<typename T, typename U>
UNKNOWN func(T&& t, U&& u){ return t + u; };
```
Так можно было бы записать тип с помощью `decltype` и `auto`:  
```C++
//C++11
template<typename T, typename U>
auto myFunc(T&& t, U&& u) -> decltype (forward<T>(t) + forward<U>(u))
        { return forward<T>(t) + forward<U>(u); };

//C++14
template<typename T, typename U>
decltype(auto) myFunc(T&& t, U&& u)
        { return forward<T>(t) + forward<U>(u); };
```
В  этом примере `decltype` позволяет использовать универсальные ссылки, так как не теряет важных сведений о том, возвращает ли функция ссылочный тип.  

### decltype(auto)
Появилось в C++14.
В предыдущем примере присутствует конструкция `decltype(auto)`. Что это такое?  
Это фишка языка, появившаяся в С++14. Она нужна для сохранения семантики (правил вывода типов) `decltype` при объявлении `auto` переменных (или типа возвращаемого функцией значения) и используется в тех случаях, когда нас не устраивает то, что auto отбрасывает ссылки и cv квалификаторы.  

То есть, мы можем выводить тип из выражения инициализатора (или выражения return) по правилам `decltype`:
```C++
const int&& foo();
auto i = foo(); //  i будет иметь тип int
dectype(auto) i2 = foo(); //  i2 будет иметь тип const int&&
```
В последнем случае мы могли бы написать decltype(foo()), но представьте, если бы вместо foo() было выражение на 2 строчки, а такие в С++ не редкость.  

## Интересные примеры и тонкие места
Различие между decltype и auto в том, что auto теряет квалификаторы типов const и &, а decltype сохраняет их.  

decltype vs typeid: decltype предоставляет информацию о типе во время компиляции, а typeid - во время выполнения. Итак, если у нас есть указатель базового класса, ссылающийся на объект производного класса, decltype выведет тип как указатель на базовый класс, а typeid определит указатель на объект производного типа.  

decltype не вычисляет переданное ему выражение, а только оценивает его тип во время компиляции.  Поэтому возможно писать даже выражения, приводящие к UB (если бы выполнялись в другом контексте):  
```C++
int i = 42;
int * ptr = nullptr;
decltype(*ptr) j = i;
```

Нужно быть аккуратным, помня, что если параметр expression является lvalue, то decltype(expression) является ссылкой.  
Поэтому в предыдущем примере `j` является ссылкой на `i`:  
```C++
int i = 42;
int * ptr = nullptr;
decltype(*ptr) j = i;  // int&
j = 24;
std::cout << i << std::endl;  // 24
```
Так же ссылка будет создана в таком выражении:  
```C++
decltype((i)) j2 = i;  // int&
j2 = 0;
std::cout << i << std::endl;  // 0
```
Но если в `decltype` передано не выражение, а индентификатор, то тип будет в точности такой, как у переданной переменной:
```C++
decltype(i) j3 = i;  // int
```


