# decltype
## Что это такое?
decltype — ключевое слово языка программирования C++, которое появилось в обновлённом стандарте C++11. 
Наряду с ключевым словом auto оно используется для выведения типов выражений, получаемых в качестве своего аргумента.  

Различие между decltype и auto в том, что auto теряет квалификаторы типов const и &, а decltype сохраняет их для дальнейшей работы.  

Также в стандарте С++11 ключевое слово decltype можно использовать для объявления типа возвращаемого функцией значения в тех случаях, 
когда применяется новый способ записи сигнатуры функции (в котором возвращаемое значение следует за списком её параметров).  

В обновлённом стандарте языка C++14 появилась возможность объявлять переменные со спецификатором типа decltype(auto), который предписывает компилятору выбирать для них тип данных на основе типа инициализатора.  

## Как использовать decltype?
decltype возвращает тип указанного выражения. 
decltype полезен, в основном, для разработчиков, создающих библиотеки шаблонов.  

Для определения типа параметра выражения компилятор использует следующие правила:  
 * Если параметр является идентификатором или выражением доступа к члену класса, то decltype(expression) в точности является типом сущности с именем expression.  
 * Если параметр является результатом вызова функции или оператора, то аргумент decltype(expression) является типом возвращаемого значения функции. Скобки вокруг перегруженного оператора игнорируются.  
 * Если параметр Expression является rvalue, то decltype(expression) является типом выражения. Если параметр Expression является lvalue, то decltype(expression) является ссылкой.  

Различие между decltype и auto в том, что auto теряет квалификаторы типов const и &, а decltype сохраняет их.  

decltype не вычисляет переданное ему выражение, а только оценивает его тип во время компиляции.  

Пример:  
```C++
int var;
const int&& fx();
struct A { double x; }
const A* a = new A();

decltype(fx()); 	// const int&&: cсылка rvalue на const int.
decltype(var); 	// int: тип переменной var.
decltype(a->x);  // double: тип поля x.
decltype((a->x));  // const double&: внутренние скобки делают аргумент выражением, а не доступом к члену класса. И, поскольку a объявляется как const указатель, тип является ссылкой на const double.
```

Ещё пример:  
```C++
int i;
decltype(i); // int
decltype(i + 1); // int
decltype((i)); // int&
decltype(i = 4); //int&
const int foo();
decltype(foo()) ;// int
int&& foo1();
decltype(foo1()) ;// int&&
```

### При инициализации

### Возвращаемое значение функции

### decltype(auto)
Появилось в C++14

## Интересные примеры и тонкие места

