# move semantic и rvalues
## Введение
В рунете опубликовано много материалов по семантике перемещения и rvalues в C++. Но это тема до сих пор вызывает массу вопросов у начинающих разработчиков. Я предпринял попытку помочь некоторым из них и изложил свой взгляд на семантику перемещения в C++. Возможно, кому-то этот взгляд покажется близким и поможет разобраться в не самой простой теме. Информация и примеры взяты из открытых источников, подача и порядок изложения взяты из моей головы. Ссылки на использованные источники привожу в конце статьи. Поехали...  

## Кратко: что такое семантика перемщения?
Семантика перемещения (англ. move semantics) — собирательное название специализированных средств языка программирования C++, 
которые предназначены для осуществления перемещения данных во время инициализации и конструирования новых объектов, 
что позволяет сократить издержки на копирование. 
Для практического осуществления семантики перемещения в синтаксис C++ введены rvalue ссылки, 
а также конструкторы перемещения и перемещающий оператор присваивания.  

Появление в стандарте языка C++ семантики перемещения состоялось с выходом обновлённого стандарта C++11; 
оно было продиктовано необходимостью оптимизировать вычислительные расходы там, где до этого применялась семантика передачи по значению.  

Введение семантики перемещения данных в стандарт языка получило высокую оценку сообщества разработчиков ввиду того, 
что она даёт широкие возможности для оптимизации внутреннего кода вызовов функций и методов классов. 
Эта оптимизация достигается отказом от копирования данных при создании временных объектов, у которых отсутствует необходимость 
сохранять их внутренние ресурсы для дальнейшего использования.  

Появление в стандарте семантики перемещения потребовало формализовать вывод аргументов параметризованных типов (шаблонов) и их использование, 
в связи с чем появился регламент прямой передачи, а «правило трёх» эволюционировало в «правило пяти»: 
теперь при управлении памятью помимо конструктора копирования, деструктора и копирующего оператора присваивания разработчику 
требуется определить конструктор перемещения и перемещающий оператор присваивания. 
Компилятору разрешено их автоматически задействовать тогда, когда их аргументы соответствуют определению rvalue.  

## Мотивация
В C++ существовали следующие способы передачи объекта в другой контекст: по значению, по указателю и по ссылке. Все они подразумевают либо создание копии объекта (передача по значению), либо совместное владение объектом (передача по указателю или ссылке). В определённых ситуациях полезна бывает другая семантика передачи - семантика перемещения, т.е. передачи владения объектом в новый контекст. Это не создание нового объекта, как для копии, и не совместное владение, как для указателя и ссылки, а передача владения, т.е. объект становится недоступен в прежнем контексте, и работать с объектом можно в новом контексте, куда он перемещён. Это может быть полезно в следующих ситуациях:  
1. Чтобы избежать дорогого копирования объектов в ситуациях, когда объект больше не нужен в прежнем контексте.  
Например, при передаче в функцию временного объекта:
```C++
class MyClass {
  // code here
}
void foo(MyClass obj) { /* code here */ }

foo(MyClass());
```
Строгая примитивная последовательность действий в этом примере такая: вызов дефолтного конструктора для создания временного объекта, вызов конструктора копирования для создания копии, вызов функции, вызов деструктора для копии, вызов деструктора для временного объекта. Очевидно, что создание копии здесь излишне, достаточно было бы создания одного объекта.  
К счастью, во всех похожих ситуациях современные компиляторы проводят оптимизации и избегают лишних копирований. Подробнее об этом:  
[Copy elision](https://en.cppreference.com/w/cpp/language/copy_elision)  
[RVO и NRVO](http://alenacpp.blogspot.com/2008/02/rvo-nrvo.html)  
То есть заботу о лишних копиях берёт на себя компилятор, поэтому подробно на этом останавливаться не будем. Скажем только, что **нельзя строить логику работы на количествах вызовов конструкторов/деструкторов**, потому что создания объектов могут быть соптимизированы компилятором, даже если конструктор/деструктор имеет наблюдаемые побочные эффекты (делает что-то кроме создания/удаления объекта).  

2. Чтобы реализовать безопасные типы «только для перемещения»; то есть типы, для которых копирование не имеет смысла, а перемещение имеет смысл. Например, потоки, файлы и другие ресурсы, а также объекты, копирование которых противоречит бизнес-логике, но владение которыми может передаваться.  
Этот кейс будем рассматривать в качестве основного, потому что реализация такого поведения ложится на разработчиков.  
Другими словами, часто требуется реализовать такие правила владения, чтобы у значения/объекта/ресурса был только один владелец в один момент времени ([такие правила владения действуют по умолчанию в языке rust](https://doc.rust-lang.ru/book/ch04-01-what-is-ownership.html#Правила-владения)).  
Возможна так же ситуация, когда логика работы требует в некоторых ситуациях копировать объекты, а в некоторых других - перемещать.  

## Как можно было реализовать перемещение объектов до C++11?
В этом разделе обсуждается `std::auto_ptr`, который является устаревшим умным указателем стандартной библиотеки C++98. В C++11 с появлением семантики перемещения `std::auto_ptr` был заменен на `std::unique_ptr`. Многие программисты, вероятно, хотя бы немного знакомы с `std::auto_ptr`. Его использовали для реализации перемещения объектов до C++11, и, кажется, он является хорошей отправной точкой для изучения семантики перемещения.  

`std::auto_ptr` предлагал разработчикам эксклюзивное владение объектами (один владелец в один момент времени), а так же гарантировал корректное освобождение памяти даже при броске исключения.  

Пример использования `std::auto_ptr`:  
```C++
{
    std::auto_ptr<Shape> a(new Triangle);
    // ...
    // arbitrary code, could throw exceptions
    // ...
}   // <--- when a goes out of scope, the triangle is deleted automatically
```
Для нас важно то, как производилось "копирование" объектов `std::auto_ptr`:  
```
auto_ptr<Shape> a(new Triangle);

      +---------------+
      | triangle data |
      +---------------+
        ^
        |
        |
        |
  +-----|---+
  |   +-|-+ |
a | p | | | |
  |   +---+ |
  +---------+

auto_ptr<Shape> b(a);

      +---------------+
      | triangle data |
      +---------------+
        ^
        |
        +----------------------+
                               |
  +---------+            +-----|---+
  |   +---+ |            |   +-|-+ |
a | p |   | |          b | p | | | |
  |   +---+ |            |   +---+ |
  +---------+            +---------+
```

Обратите внимание, как инициализация `b` с помощью `a` вовсе не копирует объект Triangle, a передает право собственности на объект от `a` к `b`. Мы говорим "a будет перемещен в b" или "объект Triangle перемещается от a к b". Это может показаться запутанным, потому что сам объект Triangle всегда остается в одном и том же месте в памяти (физически он не перемещается в памяти).  
**Переместить объект означает передать владение некоторым ресурсом, которым он управляет, другому объекту.**

Конструктор копирования `auto_ptr`, вероятно, выглядел примерно так (упрощенно):  
```C++
auto_ptr(auto_ptr& source)   // note the missing const
{
    p = source.p;
    source.p = 0;   // now the source no longer owns the object
}
```

Опасность использования `std::auto_ptr` заключалась в том, что перемещение синтаксически выглядело как копирование. Нужно было быть осторожным, потому что попытка обратиться к перемещённому объекту приводила к неопределённому поведению:  
```C++
auto_ptr<Shape> a(new Triangle);   // create triangle
auto_ptr<Shape> b(a);              // move a into b
double area = a->area();           // undefined behavior
```

Но `auto_ptr` не всегда опасно. Фабричные функции - отличный вариант использования `auto_ptr`:  
```C++
auto_ptr<Shape> make_triangle()
{
    return auto_ptr<Shape>(new Triangle);
}

auto_ptr<Shape> c(make_triangle());      // move temporary into c
double area = make_triangle()->area();   // perfectly safe
```
Обратите внимание, что оба примера следуют одному и тому же синтаксическому шаблону:  
```C++
auto_ptr<Shape> variable(expression);
double area = expression->area();
```
И все же один из них вызывает неопределенное поведение, а другой - нет. Так в чем разница между выражениями `a` и `make_triangle()`? Ответ: у этих значений разные категории.  

## Категории значений до C++11 и проблема с ними
Каждое выражение в языке C++ имеет два свойства: тип и категорию значения. В C++03 и в более ранних версиях С++ l-values и r-values были единственными категориями значений.  

В примерах выше именованная переменная `a` является l-value, а временный объект, создаваемый функцией `make_triangle()` является r-value.  
Буквы l и r имеют историческое происхождение и обозначали значения, которые могут находиться слева или справа от знака `=` в выражениях присваивания, *хотя сейчас в C++ это не совсем так, и есть l-значения, которые не могут находиться в левой части выражения присваивания (например, определяемые пользователем типы без оператора присваивания), и есть r-значения, которые могут (временные объекты классов с оператором присваивания).*  

Из примеров выше мы видим, что перемещение l-values в новый контекст опасно, потому что есть риск позже обратиться к перемещённому значению и вызвать неопределённое поведение, а перемещение r-values совершенно безопасно, потому что область видимости r-values ограничена одним выражением, и мы не сможем снова обратиться к перемещённому значению.  

Мы видим, что появилась необходимость добавить в язык механизм, позволяющий отличать безопасно перемещаемые значения от тех, которые перемещать опасно, а также либо запретить перемещение l-values, либо сделать его явным, чтобы исключить случайное перемещение.  

## Что появилось в C++11 для реализации семантики перемещения?
1. Новые категории значений, учитывающие возможность/невозможность перемещения объектов.  
2. Ссылки на r-values как способ отличать безопасно перемещаемые значения от тех, которые перемещать опасно.  
3. Функции для смены категории значения, чтобы иметь возможность явно перемещать l-value значения: `std::move` и `std::forward`.  

### Категории значений в C++11
С появлением C++11 были определены дополнительные категории значений и [организованы систематическим образом](http://www.stroustrup.com/terminology.pdf) по двум признакам: можем ли мы получить адрес значения в памяти и может ли значение быть перемещено.  

![Основные категории значений в C++11](https://bajamircea.github.io/assets/2016-04-07-move-forward/value-categories.png)  

 * Если у значения можно получить адрес, но его нельзя переместить, это lvalue; в противном случае это rvalue.  
 * Если значение может быть перемещено, и нельзя получить его адрес, то это prvalue (чистое rvalue); иначе это glvalue (обобщенное lvalue).  
 * Если у значения можно получить адрес и его можно переместить, это xvalue (потому что x - хороший префикс для странных вещей).  

Это основные категории, но есть и [дополнительные](http://en.cppreference.com/w/cpp/language/value_category) (например, void - неперемещаемое значение без адреса), но их мы сейчас не будем рассматривать.  

Примеры значений разных категорий можно посмотреть [здесь](http://en.cppreference.com/w/cpp/language/value_category).  

### Ссылки на r-values
В C++11 добавили новый тип ссылок — ссылки r-value. Ссылки r-value — это ссылки, которые инициализируются только значениями r-values.  
Синтаксис выглядит следующим образом: `X&&`. Старая добрая ссылка `X&` теперь называется ссылкой на lvalue. (Обратите внимание, что `X&&` это не ссылка на ссылку; в C++ нет ссылок на ссылки).  

Что это даёт нам при написании кода? Благодаря новому синтаксису, мы можем в коде отличать ссылки на перемещаемые значения от ссылок на неперемещаемые значения, а соответственно можем писать перегрузки функций для перемещаемых объектов и для неперемещаемых объектов отдельно и наделять их разным поведением.  

Время жизни r-values обычно ограничено одним выражением, не приведёт ли возможность создания ссылок на временные объекты к появлению висячих ссылок? Нет, потому что ссылки на r-values увеличивают продолжительность жизни объекта, которым инициализируются, до продолжительности жизни ссылки r-value (константные ссылки l-value тоже могут это делать):  
```C++
int main()
{
	Fraction &&rref = Fraction(4, 7); // ссылка r-value на анонимный объект класса Fraction
	std::cout << rref << '\n';
 
	return 0;
} // rref (и анонимный объект класса Fraction) выходит из области видимости здесь
```
Создаваемый анонимный объект Fraction(4, 7) обычно вышел бы из области видимости в конце выражения, в котором он определен. Однако, так как мы инициализируем ссылку r-value этим анонимным объектом, то его продолжительность жизни увеличивается до продолжительности жизни самой ссылки r-value, т.е. до конца функции main(). Затем мы используем ссылку r-value для вывода значения анонимного объекта класса Fraction.  

Как и зачем нам обеспечивать различное поведение функций для r-values и l-values? Неконстантные ссылки r-value позволяют нам изменять значения r-values, на которые указывают ссылки r-value:  
```C++
#include <iostream>
 
int main()
{
    int &&rref = 7; // поскольку мы инициализируем ссылку r-value литералом 7, то создается временный объект со значением 7, на который указывает ссылка r-value
    rref = 12;
    std::cout << rref;
 
    return 0;
}
```
Ссылки r-value не очень часто используются так, как это представлено в вышеприведенных примерах. Ссылки r-value чаще всего используются в качестве параметров функции. Это наиболее полезно при перегрузке функций, когда вы хотите, чтобы выполнение функции отличалось в зависимости от аргументов (l-values или r-values),например, для реализации конструкторов перемещения и копирования. Получая r-value объект в конструктор перемещения мы можем забрать у него ресурсы, которыми он управляет (например, хранящиеся в куче данные), оставив r-value объект пустым. Мы можем это делать, потому что точно знаем, что этот объект больше не будет использоваться. Если же вызвана перегрузка конструктора копирования для l-value объектов, то мы реализуем копирование объекта вместе с его ресурсами, оставляя старый объект работоспособным. 

Таким образом, начиная с C++11, мы можем работать со следующими типами ссылок:  
```
            lvalue   const lvalue   rvalue   const rvalue
---------------------------------------------------------              
X&          yes
const X&    yes      yes            yes      yes
X&&                                 yes
const X&&                           yes      yes
```
На практике можно забыть о `const X&&`. Это ограничение для rvalues не очень полезно.  

#### Ссылки как параметры функции
Если функция имеет `lvalue reference` параметр, то его можно вызвать только с lvalue аргументом, но не с rvalue аргументом.  
```C++
// parameter is lvalue reference
void fn(X &) { std::cout<< "X &\n"; }

int main()
{
  X a;
  fn(a); // works, argument is an lvalue

  fn(X()); // compiler error, argument is an rvalue
}
```
Аналогично, если функция имеет `rvalue reference` параметр, тогда её можно вызвать только с rvalue аргументом, но не с lvalue аргументом.  
```C++
// parameter is rvalue reference
void fn(X &&) { std::cout<< "X &&\n"; }

int main()
{
  X a;
  fn(a); // compiler error, argument is an lvalue

  fn(X()); // works, argument is an rvalue
}
```

Обратите внимание, что при использовании параметра внутри тела функции, будь то `lvalue reference` или `rvalue reference`, параметр является lvalue: у него есть имя, как и у любой другой переменной.  
```C++
// parameter is rvalue reference
void fn(X && x)
{
  // but here expression x has an lvalue value category
  // can use std::move to convert it to an xvalue
}
```
Посмотрите на таблицу в предыдщем разделе. Интересный момент в том, что константные l-value ссылки могут связываться как с lvalue, так и с rvalue аргументами:  
```C++
// parameter is const rvalue reference
void fn(const X &) { std::cout<< "const X &\n"; }

int main()
{
  X a;
  fn(a); // works, argument is an lvalue

  fn(X()); // also works, argument is an rvalue
}
```

#### Ссылки и перегрузки функций
Мы можем написать перегрузки функции для разных категорий значений, а компилятор выберет наиболее подходящую, если же подходящей перегрузки нет, то мы получим ошибку компиляции.  
```C++
struct X {};

// overloads
void fn(X &) { std::cout<< "X &\n"; }
void fn(const X &) { std::cout<< "const X &\n"; }
void fn(X &&) { std::cout<< "X &&\n"; }

int main()
{
  X a;
  fn(a);
  // lvalue selects fn(X &)
  // fallbacks on fn(const X &)

  const X b;
  fn(b);
  // const lvalue requires fn(const X &)

  fn(X());
  // rvalue selects fn(X &&)
  // and then on fn(const X &)
}
```
В дополнение к трем вышеупомянутым перегрузкам, конечно, есть возможность перегрузки с `const X&&`, но обычно это не имеет смысла.  

Часто этот механизм используется для реализации конструкторов копирования/перемещения и операторов присваивания копированием/перемещением, в этом случае нам интересны следующие перегрузки:  
 * `const X&` для конструктора копирования или присваивания копированием
 * `X&&` для конструктора перемещения или присваивания перемещением

#### Возврат ссылки r-value
Вы почти никогда не должны возвращать ссылку r-value из функции по той же причине, по которой вы почти никогда не должны возвращать ссылку l-value из функции. В большинстве случаев вы возвратите висячую ссылку (указывающую на удаленную память), а объект, на который будет ссылаться ссылка, выйдет из области видимости в конце функции.  

#### Правила вывода типов аргументов шаблона и правила свертывания ссылок
Если шаблонная функция имеет `rvalue reference` аргумент с типом, являющимся параметром шаблона, то действуют специальные правила вывода типов. Синтаксически это похоже на использование `rvalue reference` в примерах выше, но на самом деле в этой ситуации действуют особые правила для поддержки [forwarding reference](https://habr.com/ru/post/242639/).  
```C++
template<typename T>
void foo(T &&); // forwarding reference here
// T is a template parameter for foo

template<typename T>
void bar(std::vector<T> &&); // but not here
// std::vector<T> is not a template parameter,
// only T is a template parameter for bar
```

Эти особые правила вывода типов разрешают вызывать функцию foo в примере выше с lvalue и rvalue аргументами:  
 * При вызове с lvalue, тип T будет равен `X&`  
 * При вызове с rvalue, тип T будет равен `X`  

Применяя эти правила, мы получаем аргументы типа `X& &&` и `X&&`. Для разрешения подобных ситуаций действуют правила сжатия ссылок:  
 * `X& &` сжимается до `X&`  
 * `X& &&` сжимается до `X&`  
 * `X&& &` сжимается до `X&`  
 * `X&& &&` сжимается до `X&&`  
Это правило очень простое – одиночный амперсанд (&) всегда побеждает.  

Комбинируя два правила (вывода типов и сжатия ссылок), мы получаем:  
```C++
template<typename T>
void fn(T &&) { std::cout<< "template\n"; }

int main()
{
  X a;
  fn(a);
  // argument expression is lvalue of type X
  // resolves to T being X &
  // X & && collapses to X &

  fn(X());
  // argument expression is rvalue of type X
  // resolves to T being X
  // X && stays X &&
}
```

#### Неявные преобразования
Для ссылок на rvalue `X&&` действуют стандартные правила приведения типов аргументов. В случае приведения типов создаётся временный объект нового типа, и ссылка rvalue привызывается к этому временному объекту:  
```C++
void some_function(std::string&& r);
some_function("hello world");
```
В приведенном выше примере `"hello world"` - это lvalue типа `const char[12]`. Поскольку существует неявное преобразование из `const char[12]` через `const char*` к `std::string`, создается временный объект `std::string`, и `r` привязывается к этому временному объекту.  

### std::move и std::forward
#### std::move
Из примеров выше мы видим, что в определённых ситуациях мы можем преобразовать значения одной категории в значения другой категории. Если у нас есть rvalue, мы можем присвоить это значение какой-то переменной `int a = 42;` или взять ссылку `int&& a = 42;` и ,следовательно, получить lvalue. Если у нас есть lvalue мы можем вернуть его из функции и получить rvalue.  

Но кое-чего не хватает: можно явно преобразовывать категорию значения от lvalue к rvalue (а точнее к xvalue) с помощью `static_cast<X&&>` без создания временного объекта. И это последний кусок головоломки, который нужно понять. 

То есть иногда мы хотим, чтобы компилятор обрабатывал lvalue так, как если бы это было rvalue: чтобы он мог вызывать конструктор перемещения, даже если это может быть потенциально небезопасным. Для этого C++11 предлагает функцию `std::move`. Это имя немного неудачное, потому что `std::move` сам по себе ничего не перемещает, он просто преобразует lvalue в rvalue (вызывает static_cast), делая перемещение возможным.  

Вот как мы явно можем переходить от lvalue к xvalue:  
```C++
struct X
{
  X(){}

  X(const X & other) : s_{ other.s_ } {}

  X(X && other) : s_{ std::move(other.s_) } {}
  // other is an lvalue, and other.s_ is an lvalue too
  // use std::move to force using the move constructor for s_
  // don't use other.s_ after std::move (other than to destruct)

  std::string s_;
};

int main()
{
  X a;

  X b = std::move(a);
  // a is an lvalue
  // use std::move to convert to a rvalue,
  // xvalue to be precise,
  // so that the move constructor for X is used
  // don't use a after std::move (other than to destruct)
}
```
Обратите внимание, что после строки `X b = std::move(a);` объект `a` больше не владеет строкой. Это нормально, потому что, явно написав `std::move(a)`, мы прояснили наши намерения: "Уважаемый конструктор, делайте с `a` всё, что хотите, чтобы инициализировать `c`; `a` мне больше не пригодится."  

Как работает `std::move`?  
Вот [возможная реализация](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3143.html) для std::move:  
```C++
template<typename T> struct remove_reference { typedef T type; };
template<typename T> struct remove_reference<T&> { typedef T type; };
template<typename T> struct remove_reference<T&&> { typedef T type; };

template<typename T>
constexpr typename remove_reference<T>::type && move(T && arg) noexcept
{
  return static_cast<typename remove_reference<T>::type &&>(arg);
}
```
Прежде всего `std::move` это шаблон с forwarding reference, что означает, что его можно вызвать и с lvalue, и с rvalue (см. выше правила вывода типов параметров шаблонов и правила сжатия ссылок).  
Нам не нужно явно указывать тип аргумента при использовании `std::move`, потому что он выводится автоматически.  
Всё, что делает `std::move`, - это static_cast.  
`remove_reference` используется для получения базового типа T без каких-либо ссылок, и его результат дополняется двумя амперсандами `&&` в `static_cast`.  

Вспомните или перечитайте раздел "Категории значений в C++11".  
`std::move` не создаёт временный объект. Результат `std::move` может быть перемещён, хотя это не rvalue в традиционном смысле. Это значение категории xvalue (eXpiring value).  

Теперь можете снова вернуться к описанию copy elision и RVO/NRVO.  
Компилятор может самостоятельно перемещать возвращаемые из функции локальные объекты, а так же перемещать временные объекты в функцию в качестве аргумента, даже если синтаксически это записано как передача объекта по значению. В этом случае неявно тоже работает семантика перемещения, но для этого нам не требуется использовать синтаксис перемещения, компилятор всё сделает за нас. То есть мы НЕ должны писать `return std::move(a);` чтобы избежать лишнего вызова конструктора, это произойдёт неявно при записи `return a;`.  

#### std::forward
Вспомните раздел о forwarding reference.  

std::forward, обычно, применяется, когда находится внутри шаблонной функции с аргументом объявленным как `forwarding reference`, и используется, чтобы восстановить исходную категорию параметра, который был передан в функцию, и передать его дальше по цепочке вызовов (это называется [идеальной передачей](https://habr.com/ru/post/242639/)).  

Вот пример, где используется std::forward:  
```C++
struct Y
{
  Y(){}
  Y(const Y &){ std::cout << "Copy constructor\n"; }
  Y(Y &&){ std::cout << "Move constructor\n"; }
};

struct X
{
  template<typename A, typename B>
  X(A && a, B && b) :
    // retrieve the original value category from constructor call
    // and pass on to member variables
    a_{ std::forward<A>(a) },
    b_{ std::forward<B>(b) }
  {
  }

  Y a_;
  Y b_;
};

template<typename A, typename B>
X factory(A && a, B && b)
{
  // retrieve the original value category from the factory call
  // and pass on to X constructor
  return X(std::forward<A>(a), std::forward<B>(b));
}

int main()
{
  Y y;
  X two = factory(y, Y());
  // the first argument is a lvalue, eventually a_ will have the
  // copy constructor called
  // the second argument is an rvalue, eventually b_ will have the
  // move constructor called
}

// prints:
// Copy constructor
// Move constructor
```

std::forward устроен чуть сложнее, чем std::move, но по-прежнему всё, что он делает, - это `static_cast`.  

Вот [возможная реализация](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3143.html) для std::forward:  
```C++
template<typename T> struct is_lvalue_reference { static constexpr bool value = false; };
template<typename T> struct is_lvalue_reference<T&> { static constexpr bool value = true; };

template<typename T>
constexpr T&& forward(typename remove_reference<T>::type & arg) noexcept
{
  return static_cast<T&&>(arg);
}

template<typename T>
constexpr T&& forward(typename remove_reference<T>::type && arg) noexcept
{
  static_assert(!is_lvalue_reference<T>::value, "invalid rvalue to lvalue conversion");
  return static_cast<T&&>(arg);
}
```

Из примера мы видим, что тип T не выводится автоматически, поэтому нам пришлось указать его при использовании `std::forward`.  

Кратко о том, что происходит:  
 * Первая перегрузка `std::forward` пересылает lvalues либо как lvalues, либо как rvalues, в зависимости от типа T  
 * Вторая перегрузка `std::forward` пересылает rvalues как rvalue и запрещает пересылку rvalue как lvalues  

Рассмотрим первый аргумент `factory(y, Y());`. Он имеет категорию lvalue. Тип `A` выводится как `Y&`. Получем вызов `std::forward<Y&>(Y&)` (первая перегрузка `std::forward`). После инстанцирования шаблона получаем `return static_cast<Y& &&>(arg);`. И, наконец, после сжатия ссылок получаем `return static_cast<Y&>(arg);`. Аналогично для второго аргумента. Конструктор `X(A && a, B && b)` работает похожим образом.  

Более подробно о выводе типов и выборе подходящей перегрузки в этом примере можете почитать [здесь](https://en.cppreference.com/w/cpp/utility/forward).  

Запрет на пересылку rvalues как lvalues нужен, чтобы избежать проблемы с висячими ссылками. Это объясняется более подробно в [N2835](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2835.html), но суть такова:  
```C++
forward<const Y&>(Y()); // does not compile
// static assert in forward triggers compilation failure for line above
// with "invalid rvalue to lvalue conversion"
```

Шаблонную функцию `std::forward` можно рассматривать как некоторую обертку над `static_cast<T&&>(t)`, когда T может принять значение `U&` или `U&&`, в зависимости от типа категории аргумента (lvalue или rvalue). Теперь `factory` является шаблоном, который обрабатывает любые сочетания категорий аргументов.  

## Где и как это применяется?
### Конструкторы перемещения
Часто rvalue ссылки `X&&` используются для реализации конструктора перемещения `X::X(X&& source)`. Цель такого конструктора - передать владение ресурсом от источника новому объекту.  

В C++11 `std::auto_ptr<T>` был заменен на `std::unique_ptr<T>`, который использует новые семантику и синтаксис перемещения, а потому является более безопасным, чем `std::auto_ptr<T>`. Мы разработаем и рассмотрим упрощенную версию `unique_ptr`.  
Сначала мы инкапсулируем работу с сырым указателем и перегрузим операторы `->` и `*`, чтобы наш класс был похож на указатель:  
```C++
template<typename T>
class unique_ptr
{
    T* ptr;

public:

    T* operator->() const
    {
        return ptr;
    }

    T& operator*() const
    {
        return *ptr;
    }

    explicit unique_ptr(T* p = nullptr)
    {
        ptr = p;  // мы становимся владельцем ресурса (памяти в куче)
    }

    ~unique_ptr()
    {
        delete ptr;  // освобождаем ресурс
    }
};
```
А теперь самое интересное - конструктор перемещения:  
```C++
    unique_ptr(unique_ptr&& source)   // note the rvalue reference
    {
        ptr = source.ptr;
        source.ptr = nullptr;
    }
```
Этот конструктор перемещения делает именно то, что делал конструктор копирования `auto_ptr`, но он может использоваться только с rvalues:  
```C++
unique_ptr<Shape> a(new Triangle);
unique_ptr<Shape> b(a);                 // error
unique_ptr<Shape> c(make_triangle());   // okay
```
Вторая строка не компилируется, потому что `a` является lvalue, но параметр `unique_ptr&& source` может быть привязан только к rvalue. Это именно то, что мы хотели; опасные действия не должны производиться неявно. Третья строка компилируется, потому что результат `make_triangle()` - это rvalue. Конструктор перемещения передаст владение ресурсом от временного объекта к `c`. Опять же, это именно то, что мы хотели.  

**Конструктор перемещения передает владение ресурсом новому объекту.**  

Обратите внимание, что в конструкторе перемещения мы не просто забираем ресурс в новый объект `ptr = source.ptr;`, но и забираем владение ресурсом у старого объекта `source.ptr = nullptr;`. Это важный момент, это необходимо для того, чтобы старый объект при удалении не мог очистить память (освободить ресурс), а следовательно, чтобы избежать обращения к удалённому значению и повторной очистки той же памяти новым объектом. При этом мы добиваемся того, чтобы деструктор старого объекта мог выполниться корректно, мы оставляем старый объект в неработоспособном, но корректном состоянии.  

### Операторы присваивания перемещением
Последний нерассмотренный кейс - это оператор присваивания перемещением. Его задача - освободить старый ресурс, которым владел объект слева от знака `=` в выражении присваивания, и забрать владение другим ресурсом у объекта, стоящего справа от знака `=` в выражении присваивания:  
```C++
    unique_ptr& operator=(unique_ptr&& source)   // note the rvalue reference
    {
        if (this != &source)    // beware of self-assignment
        {
            delete ptr;         // release the old resource

            ptr = source.ptr;   // acquire the new resource
            source.ptr = nullptr;
        }
        return *this;
    }
```
Обратите внимание, как эта реализация оператора присваивания перемещением дублирует логику и деструктора, и конструктора перемещения. Вы знакомы с [идиомой копирования и обмена](https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom/3279550#3279550)? Её также можно применять для семантики перемещения в качестве идиомы перемещения и обмена:  
```C++
    unique_ptr& operator=(unique_ptr source)   // note the missing reference
    {
        std::swap(ptr, source.ptr);
        return *this;
    }
```
Теперь, когда `source` - это переменная типа `unique_ptr`, он будет инициализирован конструктором перемещения; то есть аргумент будет перемещен в параметр. Аргумент по-прежнему должен быть rvalue, потому что конструктор перемещения работает для rvalue значений. Когда поток управления достигает закрывающей скобки `operator=`, `source` выходит из области видимости, автоматически освобождая старый ресурс.  

**Оператор присваивания перемещения передает владение ресурсом текущему объекту, освобождая старый ресурс. Идиома перемещения и замены упрощает реализацию.**  

### Перемещение lvalue
В нашем примере использование `std::move` могло бы выглядеть так:  
```C++
unique_ptr<Shape> a(new Triangle);
unique_ptr<Shape> b(a);              // still an error
unique_ptr<Shape> c(std::move(a));   // okay
```

Кроме того, есть ещё одна интересная ситуация, в которой необходим `std::move`.  
Рано или поздно вы напишете такой код:  
```C++
class Foo
{
    unique_ptr<Shape> member;

public:

    Foo(unique_ptr<Shape>&& parameter)
    : member(parameter)   // error
    {}
};
```
Компилятор будет жаловаться на то, что `parameter` - это lvalue. Если вы посмотрите на его тип, вы увидите ссылку на rvalue, но ссылка на rvalue просто означает «ссылку, которая привязана к rvalue»; это не означает, что ссылка сама по себе является rvalue! Действительно, `parameter` - это просто обычная переменная с именем. Вы можете использовать `parameter` сколько угодно раз внутри тела конструктора, и он всегда обозначает один и тот же объект. Неявно отходить от этого правила было бы опасно, поэтому язык запрещает это.  
**Именованная ссылка rvalue - это lvalue, как и любая другая переменная.**  

Решение состоит в том, чтобы явно обозначить перемещение:  
```C++
class Foo
{
    unique_ptr<Shape> member;

public:

    Foo(unique_ptr<Shape>&& parameter)
    : member(std::move(parameter))   // note the std::move
    {}
};
```
Вы можете спросить, что `parameter` больше не используется после инициализации member, тогда почему компилятор не производит перемещение неявно, ведь об этом можно догадаться? Вероятно, потому что это было бы слишком сложно реализовать разработчикам компилятора, например, если тело конструктора находится в другой единице трансляции.  

### Правило пяти
В C++98 компилятор неявно объявлял три специальных метода, если это было необходимо: конструктор копирования, оператор присваивания и деструктор:
```C++
X::X(const X&);              // copy constructor
X& X::operator=(const X&);   // copy assignment operator
X::~X();                     // destructor
```
Если же требовалось нестандартное поведение от этих функций, то необходимо было реализовать их вручную.  
В C++98 существовало правило трёх: если вы переопределяете вручную одну из этих функций, то необходимо переопределить все три.  
Причина этого правила заключается в том, что класс, которому требуется любой из этих трех методов, вероятно, управляет некоторым ресурсом (дескрипторами файлов, динамически выделяемой памятью и т.д.), и ему необходимы все три реализации для корректного управления этим ресурсом. Функции копирования определяют, как ресурс копируется при копировании объектов, а деструктор освобождает ресурс в соответствии с принципами RAII.  

В C++11 добавилось две новых операции, для которых компилятор умеет создавать реализацию по умолчанию:  
```C++
X::X(X&&);                   // move constructor
X& X::operator=(X&&);        // move assignment operator
```
Все эти специальные функции будут определены компилятором неявно, если ни одна из них не определена вручную.  

Поэтому в C++11 правило трёх сменилось правилом пяти: если для класса требуется реализовать хотя бы одну из пяти специальных функций-членов, и если нужна семантика перемещения, то, скорее всего, потребуется реализовать все пять методов.  

Однако, несоблюдение правила пяти, обычно, не считается ошибкой, а считается упущенной возможностью оптимизации, если соблюдается правило трёх. Если конструктор перемещения или оператор присваивания перемещением недоступны, тогда компилятор вместо этого по возможности будет использовать семантику копирования, что приведет к дополнительным операциям копирования. Если семантика перемещения нежелательна для класса, ему не нужно объявлять конструктор перемещения и оператор присваивания перемещением.  

Что означают эти правила на практике? **Если вы пишете класс, не управляющий ресурсами, нет необходимости самостоятельно объявлять какую-либо из пяти специальных функций-членов, и вы получите правильную семантику копирования и семантику перемещения по умолчанию. В противном случае вам придется самостоятельно реализовать специальные функции-члены. Конечно, если ваш класс не использует семантику перемещения, нет необходимости реализовывать специальные операции перемещения.**  

Обратите внимание, что оператор присваивания копированием и оператор присваивания перемещением могут быть объединены в один унифицированный оператор присваивания, принимающий аргумент по значению:  
```C++
X& X::operator=(X source)    // unified assignment operator
{
    swap(source);            // see my first answer for an explanation
    return *this;
}
```
Таким образом, количество реализуемых специальных операций сокращается с пяти до четырех.  

### Другие ситуации
Конечно, использование семантики перемещения не исчерпывается реализацией конструкторов и операторов присваивания.  

Например, семантика перемещения используется для добавления элементов в стандартные контейнеры. Теперь элементы в контейнер можно перемещать:  
[std::vector<T,Allocator>::push_back](https://en.cppreference.com/w/cpp/container/vector/push_back)  
[Move semantics в C++11 и STL-контейнеры](https://habr.com/ru/post/174019/)  

Но конструкторы перемещния - это наиболее распространённый пример использования. Освоив это, вы сможете без проблем использовать семантику перемещения в других контекстах.  

## Упражнения
Взято (как и многое другое в этой статье) с [Ссылки r-value](https://ravesli.com/urok-190-ssylki-r-value/).  

Какие из следующих выражений, обозначенные буквами, не скомпилируются:  
```C++
int main()
{
	int x;
 
	// Ссылки l-value
	int &ref1 = x; // A
	int &ref2 = 7; // B
 
	const int &ref3 = x; // C
	const int &ref4 = 7; // D
 
	// Ссылки r-value
	int &&ref5 = x; // E
	int &&ref6 = 7; // F
 
	const int &&ref7 = x; // G
	const int &&ref8 = 7; // H
	
	return 0;
}
```

## Ссылки на источники
Эта статья скомпонована из:  
[What is move semantics?](https://stackoverflow.com/questions/3106110/what-is-move-semantics)  
[Семантика перемещения](https://ru.wikipedia.org/wiki/Семантика_перемещения)  
[Понимание lvalue и rvalue в C и С++](https://habr.com/ru/post/348198/)  
[Ссылки r-value](https://ravesli.com/urok-190-ssylki-r-value/)  
[Идеальная передача и универсальные ссылки в C++](https://habr.com/ru/post/242639/)  
[C++ std::move and std::forward](https://bajamircea.github.io/coding/cpp/2016/04/07/move-forward.html)  
[move](https://en.cppreference.com/w/cpp/utility/move)  
[Value categories](https://en.cppreference.com/w/cpp/language/value_category)  
[Move Semantics](https://sodocumentation.net/cplusplus/topic/2129/move-semantics)  
[Rule of three](https://riptutorial.com/cplusplus/example/9867/rule-of-three)  
[Rule of five](https://riptutorial.com/cplusplus/example/5421/rule-of-five)  
