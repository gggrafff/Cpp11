# move semantic и rvalues
## Введение
Семантика перемещения (англ. move semantics) — собирательное название специализированных средств языка программирования C++, 
которые предназначены для осуществления перемещения данных во время инициализации и конструирования новых объектов, 
что позволяет сократить издержки на копирование. 
Для практического осуществления семантики перемещения в синтаксис C++ введены rvalue ссылки, 
а также конструкторы перемещения и перемещающий оператор присваивания.  

Появление в стандарте языка C++ семантики перемещения состоялось с выходом обновлённого стандарта C++11; 
оно было продиктовано необходимостью оптимизировать вычислительные расходы там, где до этого применялась семантика передачи по значению.  

Введение семантики перемещения данных в стандарт языка получило высокую оценку сообщества разработчиков ввиду того, 
что она даёт широкие возможности для оптимизации внутреннего кода вызовов функций и методов классов. 
Эта оптимизация достигается отказом от копирования данных при создании временных объектов, у которых отсутствует необходимость 
сохранять их внутренние ресурсы для дальнейшего использования.  

Появление в стандарте семантики перемещения потребовало формализовать вывод аргументов параметризованных типов (шаблонов) и их использование, 
в связи с чем появился регламент прямой передачи, а «правило трёх» эволюционировало в «правило пяти»: 
теперь при управлении памятью помимо конструктора копирования, деструктора и копирующего оператора присваивания разработчику 
требуется определить конструктор перемещения и перемещающий оператор присваивания. 
Компилятору разрешено их автоматически задействовать тогда, когда их аргументы соответствуют определению rvalue.  

## Мотивация
В C++ существовали следующие способы передачи объекта в другой контекст: по значению, по указателю и по ссылке. Все они подразумевают либо создание копии объекта (передача по значению), либо совместное владение объектом (передача по указателю или ссылке). В определённых ситуациях полезна бывает другая семантика передачи - семантика перемещения, т.е. передачи владения объектом в новый контекст. Это не создание нового объекта, как для копии, и не совместное владение, как для указателя и ссылки, а передача владения, т.е. объект становится недоступен в прежнем контексте, и работать с объектом можно в новом контексте, куда он перемещён. Это может быть полезно в следующих ситуациях:  
1. Чтобы избежать дорогого копирования объектов в ситуациях, когда объект больше не нужен в прежнем контексте.  
Например, при передаче в функцию временного объекта:
```C++
class MyClass {
  // code here
}
void foo(MyClass obj) { /* code here */ }

foo(MyClass());
```
Строгая примитивная последовательность действий в этом примере такая: вызов дефолтного конструктора для создания временного объекта, вызов конструктора копирования для создания копии, вызов функции, вызов деструктора для копии, вызов деструктора для временного объекта. Очевидно, что создание копии здесь излишне, достаточно было бы создания одного объекта.  
К счастью, во всех похожих ситуациях современные компиляторы проводят оптимизации и избегают лишних копирований. Подробнее об этом:  
[Copy elision](https://en.cppreference.com/w/cpp/language/copy_elision)  
[RVO и NRVO](http://alenacpp.blogspot.com/2008/02/rvo-nrvo.html)  
То есть заботу о лишних копиях берёт на себя компилятор, поэтому подробно на этом останавливаться не будем. Скажем только, что **нельзя строить логику работы на количествах вызовов конструкторов/деструкторов**, потому что создания объектов могут быть соптимизированы компилятором, даже если конструктор/деструктор имеет наблюдаемые побочные эффекты (делает что-то кроме создания/удаления объекта).  

2. Чтобы реализовать безопасные типы «только для перемещения»; то есть типы, для которых копирование не имеет смысла, а перемещение имеет смысл. Например, потоки, файлы и другие ресурсы, а также объекты, копирование которых противоречит бизнес-логике, но владение которыми может передаваться.  
Этот кейс будем рассматривать в качестве основного, потому что реализация такого поведения ложится на разработчиков.  
Другими словами, часто требуется реализовать такие правила владения, чтобы у значения/объекта/ресурса был только один владелец в один момент времени ([такие правила владения действуют по умолчанию в языке rust](https://doc.rust-lang.ru/book/ch04-01-what-is-ownership.html#Правила-владения)).  
Возможна так же ситуация, когда логика работы требует в некоторых ситуациях копировать объекты, а в некоторых других - перемещать.  

## Как можно было реализовать перемещение объектов до C++11?
В этом разделе обсуждается `std::auto_ptr`, который является устаревшим умным указателем стандартной библиотеки C++98. В C++11 с появлением семантики перемещения `std::auto_ptr` был заменен на `std::unique_ptr`. Многие программисты, вероятно, хотя бы немного знакомы с `std::auto_ptr`. Его использовали для реализации перемещения объектов до C++11, и, кажется, он является хорошей отправной точкой для изучения семантики перемещения.  

`std::auto_ptr` предлагал разработчикам эксклюзивное владение объектами (один владелец в один момент времени), а так же гарантировал корректное освобождение памяти даже при броске исключения.  

Пример использования `std::auto_ptr`:  
```C++
{
    std::auto_ptr<Shape> a(new Triangle);
    // ...
    // arbitrary code, could throw exceptions
    // ...
}   // <--- when a goes out of scope, the triangle is deleted automatically
```
Для нас важно то, как производилось "копирование" объектов `std::auto_ptr`:  
```
auto_ptr<Shape> a(new Triangle);

      +---------------+
      | triangle data |
      +---------------+
        ^
        |
        |
        |
  +-----|---+
  |   +-|-+ |
a | p | | | |
  |   +---+ |
  +---------+

auto_ptr<Shape> b(a);

      +---------------+
      | triangle data |
      +---------------+
        ^
        |
        +----------------------+
                               |
  +---------+            +-----|---+
  |   +---+ |            |   +-|-+ |
a | p |   | |          b | p | | | |
  |   +---+ |            |   +---+ |
  +---------+            +---------+
```

Обратите внимание, как инициализация `b` с помощью `a` вовсе не копирует объект Triangle, a передает право собственности на объект от `a` к `b`. Мы говорим "a будет перемещен в b" или "объект Triangle перемещается от a к b". Это может показаться запутанным, потому что сам объект Triangle всегда остается в одном и том же месте в памяти (физически он не перемещается в памяти).  
**Переместить объект означает передать владение некоторым ресурсом, которым он управляет, другому объекту.**

Конструктор копирования `auto_ptr`, вероятно, выглядел примерно так (упрощенно):  
```C++
auto_ptr(auto_ptr& source)   // note the missing const
{
    p = source.p;
    source.p = 0;   // now the source no longer owns the object
}
```

Опасность использования `std::auto_ptr` заключалась в том, что перемещение синтаксически выглядело как копирование. Нужно было быть осторожным, потому что попытка обратиться к перемещённому объекту приводила к неопределённому поведению:  
```C++
auto_ptr<Shape> a(new Triangle);   // create triangle
auto_ptr<Shape> b(a);              // move a into b
double area = a->area();           // undefined behavior
```

Но `auto_ptr` не всегда опасно. Фабричные функции - отличный вариант использования `auto_ptr`:  
```C++
auto_ptr<Shape> make_triangle()
{
    return auto_ptr<Shape>(new Triangle);
}

auto_ptr<Shape> c(make_triangle());      // move temporary into c
double area = make_triangle()->area();   // perfectly safe
```
Обратите внимание, что оба примера следуют одному и тому же синтаксическому шаблону:  
```C++
auto_ptr<Shape> variable(expression);
double area = expression->area();
```
И все же один из них вызывает неопределенное поведение, а другой - нет. Так в чем разница между выражениями `a` и `make_triangle()`? Ответ: у этих значений разные категории.  

## Категории значений до C++11 и проблема с ними
Каждое выражение в языке C++ имеет два свойства: тип и категорию значения. В C++03 и в более ранних версиях С++ l-values и r-values были единственными категориями значений.  

В примерах выше именованная переменная `a` является l-value, а временный объект, создаваемый функцией `make_triangle()` является r-value.  
Буквы l и r имеют историческое происхождение и обозначали значения, которые могут находиться слева или справа от знака `=` в выражениях присваивания, *хотя сейчас в C++ это не совсем так, и есть l-значения, которые не могут находиться в левой части выражения присваивания (например, определяемые пользователем типы без оператора присваивания), и есть r-значения, которые могут (временные объекты классов с оператором присваивания).*  

Из примеров выше мы видим, что перемещение l-values в новый контекст опасно, потому что есть риск позже обратиться к перемещённому значению и вызвать неопределённое поведение, а перемещение r-values совершенно безопасно, потому что область видимости r-values ограничена одним выражением, и мы не сможем снова обратиться к перемещённому значению.  

Мы видим, что появилась необходимость добавить в язык механизм, позволяющий отличать безопасно перемещаемые значения от тех, которые перемещать опасно, а также либо запретить перемещение l-values, либо сделать его явным, чтобы исключить случайное перемещение.  

## Что появилось в C++11 для реализации семантики перемещения?
1. Новые категории значений, учитывающие возможность/невозможность перемещения объектов.  
2. Ссылки на r-values как способ отличать безопасно перемещаемые значения от тех, которые перемещать опасно.  
3. Функции для смены категории значения, чтобы иметь возможность явно перемещать l-value значения: `std::move` и `std::forward`.  

### Категории значений в C++11
С появлением C++11 были определены дополнительные категории значений и [организованы систематическим образом](http://www.stroustrup.com/terminology.pdf) по двум признакам: можем ли мы получить адрес значения в памяти и может ли значение быть перемещено.  

![Основные категории значений в C++11](https://bajamircea.github.io/assets/2016-04-07-move-forward/value-categories.png)  

 * Если у значения можно получить адрес, но его нельзя переместить, это lvalue; в противном случае это rvalue.  
 * Если значение может быть перемещено, и нельзя получить его адрес, то это prvalue (чистое rvalue); иначе это glvalue (обобщенное lvalue).  
 * Если у значения можно получить адрес и его можно переместить, это xvalue (потому что x - хороший префикс для странных вещей).  

Это основные категории, но есть и [дополнительные](http://en.cppreference.com/w/cpp/language/value_category) (например, void - неперемещаемое значение без адреса), но их мы сейчас не будем рассматривать.  

Примеры значений разных категорий можно посмотреть [здесь](http://en.cppreference.com/w/cpp/language/value_category).  

### Ссылки на r-values
В C++11 добавили новый тип ссылок — ссылки r-value. Ссылки r-value — это ссылки, которые инициализируются только значениями r-values.  
Синтаксис выглядит следующим образом: `X&&`. Старая добрая ссылка `X&` теперь называется ссылкой на lvalue. (Обратите внимание, что `X&&` это не ссылка на ссылку; в C++ нет ссылок на ссылки).  

Что это даёт нам при написании кода? Благодаря новому синтаксису, мы можем в коде отличать ссылки на перемещаемые значения от ссылок на неперемещаемые значения, а соответственно можем писать перегрузки функций для перемещаемых объектов и для неперемещаемых объектов отдельно и наделять их разным поведением.  

Время жизни r-values обычно ограничено одним выражением, не приведёт ли возможность создания ссылок на временные объекты к появлению висячих ссылок? Нет, потому что ссылки на r-values увеличивают продолжительность жизни объекта, которым инициализируются, до продолжительности жизни ссылки r-value (константные ссылки l-value тоже могут это делать):  
```C++
int main()
{
	Fraction &&rref = Fraction(4, 7); // ссылка r-value на анонимный объект класса Fraction
	std::cout << rref << '\n';
 
	return 0;
} // rref (и анонимный объект класса Fraction) выходит из области видимости здесь
```
Создаваемый анонимный объект Fraction(4, 7) обычно вышел бы из области видимости в конце выражения, в котором он определен. Однако, так как мы инициализируем ссылку r-value этим анонимным объектом, то его продолжительность жизни увеличивается до продолжительности жизни самой ссылки r-value, т.е. до конца функции main(). Затем мы используем ссылку r-value для вывода значения анонимного объекта класса Fraction.  

Как и зачем нам обеспечивать различное поведение функций для r-values и l-values? Неконстантные ссылки r-value позволяют нам изменять значения r-values, на которые указывают ссылки r-value:  
```C++
#include <iostream>
 
int main()
{
    int &&rref = 7; // поскольку мы инициализируем ссылку r-value литералом 7, то создается временный объект со значением 7, на который указывает ссылка r-value
    rref = 12;
    std::cout << rref;
 
    return 0;
}
```
Ссылки r-value не очень часто используются так, как это представлено в вышеприведенных примерах. Ссылки r-value чаще всего используются в качестве параметров функции. Это наиболее полезно при перегрузке функций, когда вы хотите, чтобы выполнение функции отличалось в зависимости от аргументов (l-values или r-values),например, для реализации конструкторов перемещения и копирования. Получая r-value объект в конструктор перемещения мы можем забрать у него ресурсы, которыми он управляет (например, хранящиеся в куче данные), оставив r-value объект пустым. Мы можем это делать, потому что точно знаем, что этот объект больше не будет использоваться. Если же вызвана перегрузка конструктора копирования для l-value объектов, то мы реализуем копирование объекта вместе с его ресурсами, оставляя старый объект работоспособным. 

Таким образом, начиная с C++11, мы можем работать со следующими типами ссылок:  
```
            lvalue   const lvalue   rvalue   const rvalue
---------------------------------------------------------              
X&          yes
const X&    yes      yes            yes      yes
X&&                                 yes
const X&&                           yes      yes
```
На практике можно забыть о `const X&&`. Это ограничение для rvalues не очень полезно.  

#### Ссылки как параметры функции
Если функция имеет `lvalue reference` параметр, то его можно вызвать только с lvalue аргументом, но не с rvalue аргументом.  
```C++
// parameter is lvalue reference
void fn(X &) { std::cout<< "X &\n"; }

int main()
{
  X a;
  fn(a); // works, argument is an lvalue

  fn(X()); // compiler error, argument is an rvalue
}
```
Аналогично, если функция имеет `rvalue reference` параметр, тогда её можно вызвать только с rvalue аргументом, но не с lvalue аргументом.  
```C++
// parameter is rvalue reference
void fn(X &&) { std::cout<< "X &&\n"; }

int main()
{
  X a;
  fn(a); // compiler error, argument is an lvalue

  fn(X()); // works, argument is an rvalue
}
```

Обратите внимание, что при использовании параметра внутри тела функции, будь то `lvalue reference` или `rvalue reference`, параметр является lvalue: у него есть имя, как и у любой другой переменной.  
```C++
// parameter is rvalue reference
void fn(X && x)
{
  // but here expression x has an lvalue value category
  // can use std::move to convert it to an xvalue
}
```
Посмотрите на таблицу в предыдщем разделе. Интересный момент в том, что константные l-value ссылки могут связываться как с lvalue, так и с rvalue аргументами:  
```C++
// parameter is const rvalue reference
void fn(const X &) { std::cout<< "const X &\n"; }

int main()
{
  X a;
  fn(a); // works, argument is an lvalue

  fn(X()); // also works, argument is an rvalue
}
```

#### Ссылки и перегрузки функций
Мы можем написать перегрузки функции для разных категорий значений, а компилятор выберет наиболее подходящую, если же подходящей перегрузки нет, то мы получим ошибку компиляции.  
```C++
struct X {};

// overloads
void fn(X &) { std::cout<< "X &\n"; }
void fn(const X &) { std::cout<< "const X &\n"; }
void fn(X &&) { std::cout<< "X &&\n"; }

int main()
{
  X a;
  fn(a);
  // lvalue selects fn(X &)
  // fallbacks on fn(const X &)

  const X b;
  fn(b);
  // const lvalue requires fn(const X &)

  fn(X());
  // rvalue selects fn(X &&)
  // and then on fn(const X &)
}
```
В дополнение к трем вышеупомянутым перегрузкам, конечно, есть возможность перегрузки с `const X&&`, но обычно это не имеет смысла.  

Часто этот механизм используется для реализации конструкторов копирования/перемещения и операторов присваивания копированием/перемещением, в этом случае нам интересны следующие перегрузки:  
 * `const X&` для конструктора копирования или присваивания копированием
 * `X&&` для конструктора перемещения или присваивания перемещением

#### Возврат ссылки r-value
Вы почти никогда не должны возвращать ссылку r-value из функции по той же причине, по которой вы почти никогда не должны возвращать ссылку l-value из функции. В большинстве случаев вы возвратите висячую ссылку (указывающую на удаленную память), а объект, на который будет ссылаться ссылка, выйдет из области видимости в конце функции.  

#### Правила вывода типов аргументов шаблона и правила свертывания ссылок
Если шаблонная функция имеет `rvalue reference` аргумент с типом, являющимся параметром шаблона, то действуют специальные правила вывода типов. Синтаксически это похоже на использование `rvalue reference` в примерах выше, но на самом деле в этой ситуации действуют особые правила для поддержки так называемой [идеальной передачи](https://habr.com/ru/post/242639/).  
```C++
template<typename T>
void foo(T &&); // forwarding reference here
// T is a template parameter for foo

template<typename T>
void bar(std::vector<T> &&); // but not here
// std::vector<T> is not a template parameter,
// only T is a template parameter for bar
```

Эти особые правила вывода типов разрешают вызывать функцию foo в примере выше с lvalue и rvalue аргументами:  
 * При вызове с lvalue, тип T будет равен `X&`  
 * При вызове с rvalue, тип T будет равен `X`  

Применяя эти правила, мы получаем аргументы типа `X& &&` и `X&&`. Для разрешения подобных ситуаций действуют правила сжатия ссылок:  
 * `X& &` сжимается до `X&`  
 * `X& &&` сжимается до `X&`  
 * `X&& &` сжимается до `X&`  
 * `X&& &&` сжимается до `X&&`  
Это правило очень простое – одиночный амперсанд (&) всегда побеждает.  

Комбинируя два правила (вывода типов и сжатия ссылок), мы получаем:  
```C++
template<typename T>
void fn(T &&) { std::cout<< "template\n"; }

int main()
{
  X a;
  fn(a);
  // argument expression is lvalue of type X
  // resolves to T being X &
  // X & && collapses to X &

  fn(X());
  // argument expression is rvalue of type X
  // resolves to T being X
  // X && stays X &&
}
```

#### Неявные преобразования
Для ссылок на rvalue `X&&` действуют стандартные правила приведения типов аргументов. В случае приведения типов создаётся временный объект нового типа, и ссылка rvalue привызывается к этому временному объекту:  
```C++
void some_function(std::string&& r);
some_function("hello world");
```
В приведенном выше примере `"hello world"` - это lvalue типа `const char[12]`. Поскольку существует неявное преобразование из `const char[12]` через `const char*` к `std::string`, создается временный объект `std::string`, и r привязывается к этому временному объекту.  

### std::move и std::forward


## Упражнения
Взято (как и многое другое в этой статье) с [Ссылки r-value](https://ravesli.com/urok-190-ssylki-r-value/).  

Какие из следующих выражений, обозначенные буквами, не скомпилируются:  
```C++
int main()
{
	int x;
 
	// Ссылки l-value
	int &ref1 = x; // A
	int &ref2 = 7; // B
 
	const int &ref3 = x; // C
	const int &ref4 = 7; // D
 
	// Ссылки r-value
	int &&ref5 = x; // E
	int &&ref6 = 7; // F
 
	const int &&ref7 = x; // G
	const int &&ref8 = 7; // H
	
	return 0;
}
```
