# move semantic и rvalues
## Введение
Семантика перемещения (англ. move semantics) — собирательное название специализированных средств языка программирования C++, 
которые предназначены для осуществления перемещения данных во время инициализации и конструирования новых объектов, 
что позволяет сократить издержки на копирование. 
Для практического осуществления семантики перемещения в синтаксис C++ введены rvalue ссылки, 
а также конструкторы перемещения и перемещающий оператор присваивания.  

Появление в стандарте языка C++ семантики перемещения состоялось с выходом обновлённого стандарта C++11; 
оно было продиктовано необходимостью оптимизировать вычислительные расходы там, где до этого применялась семантика передачи по значению.  

Введение семантики перемещения данных в стандарт языка получило высокую оценку сообщества разработчиков ввиду того, 
что она даёт широкие возможности для оптимизации внутреннего кода вызовов функций и методов классов. 
Эта оптимизация достигается отказом от копирования данных при создании временных объектов, у которых отсутствует необходимость 
сохранять их внутренние ресурсы для дальнейшего использования.  

Появление в стандарте семантики перемещения потребовало формализовать вывод аргументов параметризованных типов (шаблонов) и их использование, 
в связи с чем появился регламент прямой передачи, а «правило трёх» эволюционировало в «правило пяти»: 
теперь при управлении памятью помимо конструктора копирования, деструктора и копирующего оператора присваивания разработчику 
требуется определить конструктор перемещения и перемещающий оператор присваивания. 
Компилятору разрешено их автоматически задействовать тогда, когда их аргументы соответствуют определению rvalue.  

## Мотивация
В C++ существовали следующие способы передачи объекта в другой контекст: по значению, по указателю и по ссылке. Все они подразумевают либо создание копии объекта (передача по значению), либо совместное владение объектом (передача по указателю или ссылке). В определённых ситуациях полезна бывает другая семантика передачи - семантика перемещения, т.е. передачи владения объектом в новый контекст. Это не создание нового объекта, как для копии, и не совместное владение, как для указателя и ссылки, а передача владения, т.е. объект становится недоступен в прежнем контексте, и работать с объектом можно в новом контексте, куда он перемещён. Это может быть полезно в следующих ситуациях:  
1. Чтобы избежать дорогого копирования объектов в ситуациях, когда объект больше не нужен в прежнем контексте.  
Например, при передаче в функцию временного объекта:
```C++
class MyClass {
  // code here
}
void foo(MyClass obj) { /* code here */ }

foo(MyClass());
```
Строгая примитивная последовательность действий в этом примере такая: вызов дефолтного конструктора для создания временного объекта, вызов конструктора копирования для создания копии, вызов функции, вызов деструктора для копии, вызов деструктора для временного объекта. Очевидно, что создание копии здесь излишне, достаточно было бы создания одного объекта.  
К счастью, во всех похожих ситуациях современные компиляторы проводят оптимизации и избегают лишних копирований. Подробнее об этом:  
[Copy elision](https://en.cppreference.com/w/cpp/language/copy_elision)  
[RVO и NRVO](http://alenacpp.blogspot.com/2008/02/rvo-nrvo.html)  
То есть заботу о лишних копиях берёт на себя компилятор, поэтому подробно на этом останавливаться не будем. Скажем только, что **нельзя строить логику работы на количествах вызовов конструкторов/деструкторов**, потому что создания объектов могут быть соптимизированы компилятором, даже если конструктор/деструктор имеет наблюдаемые побочные эффекты (делает что-то кроме создания/удаления объекта).  

2. Чтобы реализовать безопасные типы «только для перемещения»; то есть типы, для которых копирование не имеет смысла, а перемещение имеет смысл. Например, потоки, файлы и другие ресурсы, а также объекты, копирование которых противоречит бизнес-логике, но владение которыми может передаваться.  
Этот кейс будем рассматривать в качестве основного, потому что реализация такого поведения ложится на разработчиков.  
Другими словами, часто требуется реализовать такие правила владения, чтобы у значения/объекта/ресурса был только один владелец в один момент времени ([такие правила владения действуют по умолчанию в языке rust](https://doc.rust-lang.ru/book/ch04-01-what-is-ownership.html#Правила-владения)).  
Возможна так же ситуация, когда логика работы требует в некоторых ситуациях копировать объекты, а в некоторых других - перемещать.  

## Как можно было реализовать перемещение объектов до C++11?


## Категории значений


## Синтаксис перемещения в C++11
