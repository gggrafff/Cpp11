# move semantic и rvalues
## Введение
Семантика перемещения (англ. move semantics) — собирательное название специализированных средств языка программирования C++, 
которые предназначены для осуществления перемещения данных во время инициализации и конструирования новых объектов, 
что позволяет сократить издержки на копирование. 
Для практического осуществления семантики перемещения в синтаксис C++ введены rvalue ссылки, 
а также конструкторы перемещения и перемещающий оператор присваивания.  

Появление в стандарте языка C++ семантики перемещения состоялось с выходом обновлённого стандарта C++11; 
оно было продиктовано необходимостью оптимизировать вычислительные расходы там, где до этого применялась семантика передачи по значению.  

Введение семантики перемещения данных в стандарт языка получило высокую оценку сообщества разработчиков ввиду того, 
что она даёт широкие возможности для оптимизации внутреннего кода вызовов функций и методов классов. 
Эта оптимизация достигается отказом от копирования данных при создании временных объектов, у которых отсутствует необходимость 
сохранять их внутренние ресурсы для дальнейшего использования.  

Появление в стандарте семантики перемещения потребовало формализовать вывод аргументов параметризованных типов (шаблонов) и их использование, 
в связи с чем появился регламент прямой передачи, а «правило трёх» эволюционировало в «правило пяти»: 
теперь при управлении памятью помимо конструктора копирования, деструктора и копирующего оператора присваивания разработчику 
требуется определить конструктор перемещения и перемещающий оператор присваивания. 
Компилятору разрешено их автоматически задействовать тогда, когда их аргументы соответствуют определению rvalue.  

## Мотивация
В C++ существовали следующие способы передачи объекта в другой контекст: по значению, по указателю и по ссылке. Все они подразумевают либо создание копии объекта (передача по значению), либо совместное владение объектом (передача по указателю или ссылке). В определённых ситуациях полезна бывает другая семантика передачи - семантика перемещения, т.е. передачи владения объектом в новый контекст. Это не создание нового объекта, как для копии, и не совместное владение, как для указателя и ссылки, а передача владения, т.е. объект становится недоступен в прежнем контексте, и работать с объектом можно в новом контексте, куда он перемещён. Это может быть полезно в следующих ситуациях:  
1. Чтобы избежать дорогого копирования объектов в ситуациях, когда объект больше не нужен в прежнем контексте.  
Например, при передаче в функцию временного объекта:
```C++
class MyClass {
  // code here
}
void foo(MyClass obj) { /* code here */ }

foo(MyClass());
```
Строгая примитивная последовательность действий в этом примере такая: вызов дефолтного конструктора для создания временного объекта, вызов конструктора копирования для создания копии, вызов функции, вызов деструктора для копии, вызов деструктора для временного объекта. Очевидно, что создание копии здесь излишне, достаточно было бы создания одного объекта.  
К счастью, во всех похожих ситуациях современные компиляторы проводят оптимизации и избегают лишних копирований. Подробнее об этом:  
[Copy elision](https://en.cppreference.com/w/cpp/language/copy_elision)  
[RVO и NRVO](http://alenacpp.blogspot.com/2008/02/rvo-nrvo.html)  
То есть заботу о лишних копиях берёт на себя компилятор, поэтому подробно на этом останавливаться не будем. Скажем только, что **нельзя строить логику работы на количествах вызовов конструкторов/деструкторов**, потому что создания объектов могут быть соптимизированы компилятором, даже если конструктор/деструктор имеет наблюдаемые побочные эффекты (делает что-то кроме создания/удаления объекта).  

2. Чтобы реализовать безопасные типы «только для перемещения»; то есть типы, для которых копирование не имеет смысла, а перемещение имеет смысл. Например, потоки, файлы и другие ресурсы, а также объекты, копирование которых противоречит бизнес-логике, но владение которыми может передаваться.  
Этот кейс будем рассматривать в качестве основного, потому что реализация такого поведения ложится на разработчиков.  
Другими словами, часто требуется реализовать такие правила владения, чтобы у значения/объекта/ресурса был только один владелец в один момент времени ([такие правила владения действуют по умолчанию в языке rust](https://doc.rust-lang.ru/book/ch04-01-what-is-ownership.html#Правила-владения)).  
Возможна так же ситуация, когда логика работы требует в некоторых ситуациях копировать объекты, а в некоторых других - перемещать.  

## Как можно было реализовать перемещение объектов до C++11?
В этом разделе обсуждается `std::auto_ptr`, который является устаревшим умным указателем стандартной библиотеки C++98. В C++11 с появлением семантики перемещения `std::auto_ptr` был заменен на `std::unique_ptr`. Многие программисты, вероятно, хотя бы немного знакомы с `std::auto_ptr`. Его использовали для реализации перемещения объектов до C++11, и, кажется, он является хорошей отправной точкой для изучения семантики перемещения.  

`std::auto_ptr` предлагал разработчикам эксклюзивное владение объектами (один владелец в один момент времени), а так же гарантировал корректное освобождение памяти даже при броске исключения.  

Пример использования `std::auto_ptr`:  
```C++
{
    std::auto_ptr<Shape> a(new Triangle);
    // ...
    // arbitrary code, could throw exceptions
    // ...
}   // <--- when a goes out of scope, the triangle is deleted automatically
```
Для нас важно то, как производилось "копирование" объектов `std::auto_ptr`:  
```
auto_ptr<Shape> a(new Triangle);

      +---------------+
      | triangle data |
      +---------------+
        ^
        |
        |
        |
  +-----|---+
  |   +-|-+ |
a | p | | | |
  |   +---+ |
  +---------+

auto_ptr<Shape> b(a);

      +---------------+
      | triangle data |
      +---------------+
        ^
        |
        +----------------------+
                               |
  +---------+            +-----|---+
  |   +---+ |            |   +-|-+ |
a | p |   | |          b | p | | | |
  |   +---+ |            |   +---+ |
  +---------+            +---------+
```

Обратите внимание, как инициализация `b` с помощью `a` вовсе не копирует объект Triangle, a передает право собственности на объект от `a` к `b`. Мы говорим "a будет перемещен в b" или "объект Triangle перемещается от a к b". Это может показаться запутанным, потому что сам объект Triangle всегда остается в одном и том же месте в памяти (физически он не перемещается в памяти).  
**Переместить объект означает передать владение некоторым ресурсом, которым он управляет, другому объекту.**

Конструктор копирования `auto_ptr`, вероятно, выглядел примерно так (упрощенно):  
```C++
auto_ptr(auto_ptr& source)   // note the missing const
{
    p = source.p;
    source.p = 0;   // now the source no longer owns the object
}
```

Опасность использования `std::auto_ptr` заключалась в том, что перемещение синтаксически выглядело как копирование. Нужно было быть осторожным, потому что попытка обратиться к перемещённому объекту приводила к неопределённому поведению:  
```C++
auto_ptr<Shape> a(new Triangle);   // create triangle
auto_ptr<Shape> b(a);              // move a into b
double area = a->area();           // undefined behavior
```

Но `auto_ptr` не всегда опасно. Фабричные функции - отличный вариант использования `auto_ptr`:  
```C++
auto_ptr<Shape> make_triangle()
{
    return auto_ptr<Shape>(new Triangle);
}

auto_ptr<Shape> c(make_triangle());      // move temporary into c
double area = make_triangle()->area();   // perfectly safe
```
Обратите внимание, что оба примера следуют одному и тому же синтаксическому шаблону:  
```C++
auto_ptr<Shape> variable(expression);
double area = expression->area();
```
И все же один из них вызывает неопределенное поведение, а другой - нет. Так в чем разница между выражениями `a` и `make_triangle()`? Ответ: у этих значений разные категории.  

## Категории значений до C++11 и проблема с ними
Каждое выражение в языке C++ имеет два свойства: тип и категорию значения. В C++03 и в более ранних версиях С++ l-values и r-values были единственными категориями значений.  

В примерах выше именованная переменная `a` является l-value, а временный объект, создаваемый функцией `make_triangle()` является r-value.  
Буквы l и r имеют историческое происхождение и обозначали значения, которые могут находиться слева или справа от знака `=` в выражениях присваивания, *хотя сейчас в C++ это не совсем так, и есть l-значения, которые не могут находиться в левой части выражения присваивания (например, определяемые пользователем типы без оператора присваивания), и есть r-значения, которые могут (временные объекты классов с оператором присваивания).*  

Из примеров выше мы видим, что перемещение l-values в новый контекст опасно, потому что есть риск позже обратиться к перемещённому значению и вызвать неопределённое поведение, а перемещение r-values совершенно безопасно, потому что область видимости r-values ограничена одним выражением, и мы не сможем снова обратиться к перемещённому значению.  

Мы видим, что появилась необходимость добавить в язык механизм, позволяющий отличать безопасно перемещаемые значения от тех, которые перемещать опасно, а также либо запретить перемещение l-values, либо сделать его явным, чтобы исключить случайное перемещение.  

## Что появилось в C++11 для реализации семантики перемещения?
1. Новые категории значений, учитывающие возможность/невозможность перемещения объектов.  
2. Ссылки на r-values как способ отличать безопасно перемещаемые значения от тех, которые перемещать опасно.  
3. Функции для смены категории значения, чтобы иметь возможность явно перемещать l-value значения: `std::move` и `std::forward`.  

### Категории значений в C++11
С появлением C++11 были определены дополнительные категории значений и [организованы систематическим образом](http://www.stroustrup.com/terminology.pdf) по двум признакам: можем ли мы получить адрес значения в памяти и может ли значение быть перемещено.  

![Основные категории значений в C++11](https://bajamircea.github.io/assets/2016-04-07-move-forward/value-categories.png)  

 * Если у значения можно получить адрес, но его нельзя переместить, это lvalue; в противном случае это rvalue.  
 * Если значение может быть перемещено, и нельзя получить его адрес, то это prvalue (чистое rvalue); иначе это glvalue (обобщенное lvalue).  
 * Если у значения можно получить адрес и его можно переместить, это xvalue (потому что x - хороший префикс для странных вещей).  

Это основные категории, но есть и [дополнительные](http://en.cppreference.com/w/cpp/language/value_category) (например, void - неперемещаемое значение без адреса), но их мы сейчас не будем рассматривать.  

Примеры значений разных категорий можно посмотреть [здесь](http://en.cppreference.com/w/cpp/language/value_category).  

### Ссылки на r-values

### std::move и std::forward
